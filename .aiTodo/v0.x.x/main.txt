На экране MainActivity хакерская текстовая арея на весь, свободный от кнопки экран, и снизу кнопка "Далее", которая станет активна только после успешного завершения операции, чтобы юзер переместился на DownloadActivity. Textarea поддерживает перемотку, всегда держится на нижней строке при любом изменении контента, поддерживает копирование в буффер.

Все логи и события внутри проги отдельным thread-ом льются в эту Textarea, logcat не юзаем, юзаем Textarea. Проливка потоков текста в Textarea должно осуществляться без буфферизации, например, всё что пишет yt-dlp, и stdout, и stderr должно непрерывно поступать в нашу консоль по мере вытекания из yt-dlp.

Используем 6 фундаментальных констант: ENV_NAME (всегда "ytgui-env"), ENV_VERSION (например, "1.7.0"), PYTHON_PATH (например, "bin/python3.12"), FFMPEG_PATH (например, "bin/ffmpeg"), LD_LIBRARY_PATH (например, "lib"), ZIP_SIZE (например, 127, в мегабайтах) - их меняет человек ответственный за сборку env. Весь наш код опирается на них при работе с путями и опциями. Чтобы получить полный рабочий путь, нужно: getFilesDir() + "/" + ENV_NAME + "/" + *_PATH.

Запускать yt-dlp (python -m) нужно, передавая питону LD_LIBRARY_PATH через процессбилдер, чтобы питон смотрел носом в окружение, где для него собрали всё необходимое. Рабочей папкой должен быть ENV_NAME. Сохранять yt-dlp должен в files (откуда мы будем юзать ScopedStorage, чтобы переместить в Documents/...), а значит нужно передать опцию yt-dlp с папкой назначения.

== MainActivity режим запуска
Код MainActivity работает в двух режимах. Если программа только запущена и параметров не передали (null), то пишем в нашу хакерскую консоль "Качаем yt-dlp" + ENV_VERSION + "... ~" + ZIP_SIZE + "Мб\n". Линк выглядит, например, так: https://github.com/Luwerdwighime/ytgui-env/archive/refs/tags/v1.7.0.zip .

Тэги ГитХаба - это "v" + ENV_VERSION, имя зипака - "v" + ENV_VERSION + ".zip", внутри зипака папка "ytgui-env-" + ENV_VERSION (без "v"), не путайся - правила ГитХаба.

Пишем "Распаковка ytgui-env...", распаковываем зипак в files. Поскольку мы копируем блоками и знаем общий размер зипака, то мы можем вычислить текущий процент распакованного, относительно запакованного. Отбиваем в консоль каждые 20% и последний процент последнего блока (да, я знаю, что будет больше 100%, но это интересно с образовательной точки зрения).

Прсле распаковки получаем папку "ytgui-env-" + ENV_VERSION, переименовываем в просто "ytgui-env", удаляем зипак (вообще, не оставляем за собой мусор), устанавливаем бит выполнения на FFMPEG_PATH и PYTHON_PATH. Когда установка окружения успешно завершена, пишем "ytgui-env установлен!" и светится кнопка "Далее".

== MainActivity режим закачки
Если получен параметр options, значит нас вызвал DownloadActivity. Он передал нам аналог std::string[] - это опции к yt-dlp, их может быть разное количество от 0 до ~10. В этом режиме мы запускаем процесс yt-dlp (как модуль, python -m) внутри скачанного окружения ytgui-env. Нужно запустить команду и отдельным потоком захватить stdout и stderr, аккуратно последовательно без буфферизации лить строки из потока в нашу хакерскую консоль (textarea). Требуется указать переменные окружения для работы внутри ytgui-env: PREFIX=${getFilesDir() + "/" + ENV_NAME}, PATH=$PREFIX/bin:$PATH, LD_LIBRARY_PATH=${наша константа LD_LIBRARY_PATH}:$LD_LIBRARY_PATH. Надеюсь, ты понимаешь этот микс c++ и bash

В качестве папки назначения используются: для видео и видеоплейлистов папка Documents/ytVideo, для аудио и аудиоплейлистов Documents/ytAudio. Питон не имеет право записи в эти папки, а потому скачивать будем в files/ytVideo, files/ytAudio и перекладывать в Documents, юзая ScopedStorage. Очевидно, что помимо манифеста нужно запросить разрешение у юзера в момент запуска программы, т.е. сделать это нужно тут, в режиме закачки MainActivity. Для плейлистов у yt-dlp запрашивается сохранение в виде папка-альбом/файл-трек. Documents - та самая, что в общем доступе на внутренней флешке, для которой запрашивался андроид доступ. Т.е. работаем внутри окружения, а сохраняем во вне, на /storage/emulated/0/...

Чтобы не парить мозг, после работы yt-dlp, запустим нашу функцию moveDownloaded(), которая перенесёт рекурсивно содержимое files/ytVideo/* в Documents/ytVideo и files/ytAudio/* в Documents/ytAudio юзая ScopedStorage. Не нужно знать, что именно было скачано - переносим контент обеих папок каждый раз после успешной скачки.

По завершении работы yt-dlp и moveDownloaded(), кнопка "Далее" внизу экрана становится акивной, и юзер, после ознакомления с консолью, может вернуться на DownloadActivity. В случае ошибки yt-dlp мы не падаем, хватаем код возврата, последнюю строку из stderr и (1) отпечатываем всё в консоли, (2) показываем тоаст с этим текстом (зацепим внимание юзера, чтобы копипастил ошибку из textarea в чат суппорту).

Когда мы входим в режим закачки, то зипак уже считается скачанным. Если файл PYTHON_PATH отсутствует, то мы пишем в консоль "Окружение " + ENV_VERSION + " повреждено. Требуется переустановка этой программы" и дальше ничего не делаем.

